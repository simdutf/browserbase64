<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Uint8Array.fromBase64() Benchmark</title>
<style>
  body { font-family: system-ui, sans-serif; max-width: 900px; margin: 40px auto; padding: 0 20px; line-height: 1.5; }
  pre { background: #f4f4f4; padding: 16px; border-radius: 8px; overflow-x: auto; }
  input, button, select { font-size: 1rem; padding: 8px 12px; margin-right: 8px; }
  #results { margin-top: 20px; font-family: monospace; white-space: pre; }
  .note { font-size: 0.9rem; color: #555; }
  #spinner {
    display: none;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #3498db;
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 2s linear infinite;
    margin: 20px auto;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>
<!-- Benchmarking library (Benchmark.js) -->
<script src="lodash.min.js"></script>
<script src="benchmark.min.js"></script>
<script src="chart.min.js"></script>
</head>
<body>

<h1>Uint8Array Base64 Benchmark</h1>

<p>This page benchmarks the <code>Uint8Array.toBase64()</code> and <code>Uint8Array.fromBase64()</code> methods that landed in browsers in 2025.</p>

<p>These new functions are fast, simple and safe.</p>

<pre class="code_syntax" style="color:#000000;background:#ffffff;"><span class="line_wrapper">const b64 <span style="color:#808030; ">=</span> Base64<span style="color:#808030; ">.</span>toBase64<span style="color:#808030; ">(</span><span style="color:#400000; ">bytes</span><span style="color:#808030; ">)</span><span style="color:#808030; ">;</span>      <span style="color:#44aadd; ">//</span> string          </span>
<span class="line_wrapper">const recovered <span style="color:#808030; ">=</span> Base64<span style="color:#808030; ">.</span>fromBase64<span style="color:#808030; ">(</span>b64<span style="color:#808030; ">)</span><span style="color:#808030; ">;</span> <span style="color:#44aadd; ">//</span> Uint8Array<span style="color:#808030; ">,</span> matches original <span style="color:#800000; ">'</span><span style="color:#0000e6; ">bytes</span><span style="color:#800000; ">'</span></span></pre>

<p>To see how fast they are in your browser, hit the button.</p>


<div>
  <button id="start">Run Benchmark</button>
</div>

<div id="spinner"></div>

<div id="results"></div>

<canvas id="chart" width="800" height="400"></canvas>


<script>
// Helper to format bytes nicely
function formatBytes(bytes) {
  if (bytes < 1024) return bytes + ' B';
  if (bytes < 1024*1024) return (bytes/1024).toFixed(1) + ' KiB';
  return (bytes/(1024*1024)).toFixed(2) + ' MiB';
}


document.getElementById('start').addEventListener('click', () => {
  const resultsDiv = document.getElementById('results');

  // Check support first
  if (typeof Uint8Array.prototype.toBase64 !== 'function' ||
      typeof Uint8Array.fromBase64 !== 'function') {
    resultsDiv.textContent = 'Error: Your browser does not support the native Uint8Array Base64 methods yet.\nUpdate to Chrome/Edge 130+, Firefox 132+, or Safari 19+.';
    return;
  }

  resultsDiv.textContent = 'Running…\n';


  // Show spinner and disable button
  document.getElementById('spinner').style.display = 'block';
  document.getElementById('start').disabled = true;

  setTimeout(async () => {

    // Use a lightweight pseudo-random generator to avoid overloading
    // the system RNG when generating large buffers repeatedly.
    function pseudoRandomBytes(len) {
      const out = new Uint8Array(len);
      // simple 32-bit LCG seeded by Math.random()
      let seed = Math.floor(Math.random() * 0xFFFFFFFF) >>> 0;
      for (let i = 0; i < len; i++) {
        seed = (seed * 1664525 + 1013904223) >>> 0;
        out[i] = seed & 0xFF;
      }
      return out;
    }

    // Payload sizes to test (fixed list; selector removed)
    const sizeOptions = [1024, 16384, 32768, 65536];
    resultsDiv.textContent = 'Running benchmarks for all payload sizes...\n\n';

    const results = [];

    // run sequentially for each size
    for (const s of sizeOptions) {
      resultsDiv.textContent += `--- Payload size: ${formatBytes(s)} ---\n`;

      const orig = pseudoRandomBytes(s);
      const b64 = orig.toBase64();
      const bytesDecoded = Math.floor(b64.length * 3 / 4);
      const bytesEncoded = orig.length;

      

      // Using Benchmark.js: return a promise that resolves when suite completes
      await new Promise((resolve) => {
        const suite = new Benchmark.Suite();

        suite.add('Uint8Array.fromBase64()', function() {
          Uint8Array.fromBase64(b64);
        }, { minSamples: 5 });

        suite.add('Uint8Array.toBase64()', function() {
          orig.toBase64();
        }, { minSamples: 5 });
        suite.on('cycle', function(event) {
          const name = event.target.name;
          const hz = event.target.hz || 0;
          const ms = hz > 0 ? 1000 / hz : Infinity;
          const bytes = name.includes('fromBase64') ? bytesDecoded : bytesEncoded;
          const mbps = hz > 0 ? (bytes * hz / (1024*1024)) : 0;
          const msDisplay = isFinite(ms) ? Number(ms).toPrecision(3) : '∞';
          const line = `${name.padEnd(32)} ${msDisplay} ms → ${mbps.toFixed(2)} MiB/s\n`;
          resultsDiv.textContent += line;
          results.push({ size: s, name, hz, mbps: parseFloat(mbps) });
        });

        suite.on('complete', function() {
          // validation
          let valid = false;
          try {
            const decoded = Uint8Array.fromBase64(b64);
            valid = decoded && decoded.length === orig.length;
            if (valid) {
              for (let i = 0; i < orig.length; i++) { if (decoded[i] !== orig[i]) { valid = false; break; } }
            }
          } catch (e) {
            resultsDiv.textContent += `\nValidation     : error (${e.message})\n\n`;
            resolve();
            return;
          }
          resultsDiv.textContent += `\nValidation     : ${valid ? 'OK' : 'MISMATCH'}\n`;
          const fastest = suite.filter('fastest').map('name');
          resultsDiv.textContent += `Fastest: ${fastest.join(', ')}\n\n`;
          resolve();
        });

        suite.run({ async: true });
      });
    }
    // All benchmarks finished — prepare and draw chart
    try {
      // Hide spinner and re-enable button
      document.getElementById('spinner').style.display = 'none';
      document.getElementById('start').disabled = false;

      // Prepare labels (sizes) and datasets
      const sizes = [...new Set(results.map(r => r.size))].sort((a,b)=>a-b);
      const labels = sizes.map(s => formatBytes(s));

      const names = Array.from(new Set(results.map(r => r.name)));
      const datasets = names.map((name, idx) => {
        const data = sizes.map(sz => {
          const entry = results.find(r => r.size === sz && r.name === name);
          return entry ? entry.mbps : 0;
        });
        const colors = ['#4e79a7','#f28e2b','#e15759','#76b7b2'];
        return {
          label: name,
          data,
          backgroundColor: colors[idx%colors.length],
        };
      });

      // Destroy previous chart if any
      if (window._base64Chart instanceof Chart) {
        window._base64Chart.destroy();
      }

      const ctx = document.getElementById('chart').getContext('2d');
      window._base64Chart = new Chart(ctx, {
        type: 'bar',
        data: { labels, datasets },
        options: {
          responsive: true,
          plugins: {
            title: { display: true, text: 'Base64 Benchmark (MiB/s) by payload size' },
            tooltip: { mode: 'index', intersect: false }
          },
          scales: {
            y: { beginAtZero: true, title: { display: true, text: 'MiB/s' } }
          }
        }
      });
    } catch (e) {
      resultsDiv.textContent += `\nChart error: ${e.message}\n`;
    }
  }, 50);
});
</script>

</body>
</html>